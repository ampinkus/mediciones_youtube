<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jobs/medicionYoutube.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jobs/medicionYoutube.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// src/jobs/medicionYoutube.js
import fetch from "node-fetch";
import sequelize from "../database/database.js";
import StreamYouTube from "../models/streams_youtube.js";
import ConfiguracionYouTube from "../models/configuracion_youtube.js";
import MedicionYouTube from "../models/mediciones_youtube.js";
import { extraerVideoID } from "../controllers/utils.controller.js";
import { DateTime } from "luxon";

import { apiKey } from "../config/youtube.config.js";

const medicionesActivas = new Map();

/**
 * Convierte una hora en formato UTC a la hora local de Argentina (HH:mm:ss).
 * @param {string|null} utcString - Hora en formato ISO UTC.
 * @returns {string|null} - Hora convertida a la zona 'America/Argentina/Buenos_Aires'.
 */
function convertirAHoraArgentina(utcString) {
  if (!utcString) return null;
  return DateTime.fromISO(utcString, { zone: 'utc' })
    .setZone('America/Argentina/Buenos_Aires')
    .toFormat('HH:mm:ss');
}

/**
 * Obtiene y guarda los datos de un stream de YouTube.
 * @param {object} stream - Objeto del stream con datos y configuraci√≥n.
 */
async function obtenerDatosYouTube(stream) {
  try {
    const videoID = extraerVideoID(stream.url_stream);
    const channelID = stream.id_canal;

    const channelUrl = `https://www.googleapis.com/youtube/v3/channels?part=snippet,contentDetails,statistics&amp;id=${channelID}&amp;key=${apiKey}`;
    const videoUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics,liveStreamingDetails&amp;id=${videoID}&amp;key=${apiKey}`;

    const [channelResponse, videoResponse] = await Promise.all([
      fetch(channelUrl).then((res) => res.json()),
      fetch(videoUrl).then((res) => res.json()),
    ]);

    const channel = channelResponse.items?.[0];
    const video = videoResponse.items?.[0];
    const lsd = video?.liveStreamingDetails;

    const config = await ConfiguracionYouTube.findOne({
      where: { streamId: stream.id },
    });

    const actualStartTime = lsd?.actualStartTime || null;
    const actualEndTime = lsd?.actualEndTime || null;
    const concurrentViewers = lsd?.concurrentViewers
      ? parseInt(lsd.concurrentViewers)
      : 0;

    console.log("üì° Respuesta de YouTube API:");
    console.log(`üîπ actualStartTime: ${actualStartTime}`);
    console.log(`üîπ actualEndTime: ${actualEndTime}`);
    console.log(`üëÅÔ∏è Espectadores concurrentes: ${concurrentViewers}`);

    if (lsd &amp;&amp; config) {
      const horaStart = convertirAHoraArgentina(lsd.actualStartTime);
      const horaEnd = convertirAHoraArgentina(lsd.actualEndTime);

      await ConfiguracionYouTube.update(
        {
          actual_start_time: horaStart,
          actual_end_time: horaEnd,
        },
        { where: { streamId: stream.id } }
      );
    } else {
      console.warn(
        `‚ö†Ô∏è No se encontr√≥ configuraci√≥n para el stream ${stream.nombre_stream}, no se actualizan horas reales`
      );
    }

    const ahoraArgentina = DateTime.now().setZone("America/Argentina/Buenos_Aires");
    const fechaLocal = ahoraArgentina.toISODate();
    const horaActual = ahoraArgentina.toFormat("HH:mm:ss");
    const fechaHoraArgentina = ahoraArgentina.toFormat("yyyy-MM-dd HH:mm:ss");
    console.log("‚Üí Fecha/hora local (Argentina):", fechaHoraArgentina);

    await MedicionYouTube.create({
      streamId: stream.id,
      fecha: fechaLocal,
      hora_medicion: horaActual,
      suscriptores_canal: parseInt(channel.statistics.subscriberCount || 0),
      cantidad_videos_canal: parseInt(channel.statistics.videoCount || 0),
      vistas_canal: parseInt(channel.statistics.viewCount || 0),
      view_count: parseInt(video.statistics.viewCount || 0),
      likes_video: parseInt(video.statistics.likeCount || 0),
      comentarios_video: parseInt(video.statistics.commentCount || 0),
      actual_start_time: stream.ConfiguracionYouTube?.actual_start_time || null,
      actual_end_time: stream.ConfiguracionYouTube?.actual_end_time || null,
      concurrent_viewers: concurrentViewers,
    });

    console.log(
      `‚úÖ Medici√≥n guardada para: ${stream.nombre_stream} (${videoID})`
    );
  } catch (error) {
    console.error(
      `‚ùå Error al obtener datos para ${stream.nombre_stream}:`,
      error
    );
  }
}

/**
 * Supervisa e inicia las mediciones para todos los streams activos.
 */
async function supervisor() {
  try {
    const streams = await StreamYouTube.findAll({
      include: ConfiguracionYouTube,
    });

    streams.forEach((stream) => {
      if (!stream.ConfiguracionYouTube) {
        console.warn(
          `‚ö†Ô∏è Stream ${stream.nombre_stream} no tiene configuraci√≥n`
        );
        return;
      }

      if (
        stream.ConfiguracionYouTube.activo &amp;&amp;
        !medicionesActivas.has(stream.id)
      ) {
        console.log(
          `üöÄ Iniciando medici√≥n din√°mica para ${stream.nombre_stream}`
        );
        medicionesActivas.set(stream.id, true);
        medirStreamConTimeout(stream);
      }
    });
  } catch (error) {
    console.error("‚ùå Error en supervisor:", error);
  }

  setTimeout(supervisor, 60 * 1000);
}

/**
 * Ejecuta una medici√≥n programada para un stream en base a su configuraci√≥n.
 * @param {object} stream - Stream a medir (puede ser parcial, solo requiere `id`).
 */
async function medirStreamConTimeout(stream) {
  try {
    const streamActualizado = await StreamYouTube.findByPk(stream.id, {
      include: ConfiguracionYouTube,
    });

    if (!streamActualizado || !streamActualizado.ConfiguracionYouTube) {
      console.warn(
        `‚ö†Ô∏è El stream con ID ${stream.id} no tiene configuraci√≥n asociada o no existe`
      );
      return;
    }

    const config = streamActualizado.ConfiguracionYouTube;

    const {
      hora_comienzo_medicion,
      hora_fin_medicion,
      intervalo_medicion,
      activo,
      fecha,
      fecha_final,
    } = config;

    const usarHoraStream = config.usar_hora_stream === true;

    const ahora = new Date();
    const hoy = DateTime.now()
      .setZone("America/Argentina/Buenos_Aires")
      .toISODate();

    if (hoy &lt; fecha || (fecha_final &amp;&amp; hoy > fecha_final)) {
      console.log(
        `‚è∞ Medici√≥n no realizada para ${
          streamActualizado.nombre_stream
        }: fuera del rango de fechas (${fecha} a ${
          fecha_final || "‚àû"
        }). Hoy es ${hoy}.`
      );
      console.log(
        `üîÑ Pr√≥xima medici√≥n en 120 segundos para ${streamActualizado.nombre_stream}`
      );
      return setTimeout(
        () => medirStreamConTimeout({ id: streamActualizado.id }),
        120 * 1000
      );
    }

    let inicio, fin;

    if (!usarHoraStream) {
      if (!hora_comienzo_medicion || !hora_fin_medicion) {
        console.log(
          `‚ö†Ô∏è Horarios manuales no definidos correctamente para ${streamActualizado.nombre_stream}. Se pospone.`
        );
        return setTimeout(
          () => medirStreamConTimeout({ id: streamActualizado.id }),
          120 * 1000
        );
      }

      const [inicioHoras, inicioMinutos, inicioSegundos = 0] =
        hora_comienzo_medicion.split(":").map(Number);
      const [finHoras, finMinutos, finSegundos = 0] = hora_fin_medicion
        .split(":")
        .map(Number);

      inicio = new Date(
        ahora.getFullYear(),
        ahora.getMonth(),
        ahora.getDate(),
        inicioHoras,
        inicioMinutos,
        inicioSegundos
      );
      fin = new Date(
        ahora.getFullYear(),
        ahora.getMonth(),
        ahora.getDate(),
        finHoras,
        finMinutos,
        finSegundos
      );

      console.log(`‚è±Ô∏è Usando horario definido manualmente por el usuario`);
    } else {
      const videoID = extraerVideoID(streamActualizado.url_stream);
      const videoUrl = `https://www.googleapis.com/youtube/v3/videos?part=liveStreamingDetails&amp;id=${videoID}&amp;key=${apiKey}`;
      const videoResponse = await fetch(videoUrl).then((res) => res.json());
      const video = videoResponse.items?.[0];

      const startTime = video?.liveStreamingDetails?.actualStartTime;
      const endTime = video?.liveStreamingDetails?.actualEndTime;

      console.log("üì° Respuesta de YouTube API:");
      console.log(`üîπ actualStartTime: ${startTime}`);
      console.log(`üîπ actualEndTime: ${endTime}`);

      if (!startTime || !endTime) {
        console.log(
          `‚ùå No se pudo obtener actualStartTime o actualEndTime para ${streamActualizado.nombre_stream}. Se pospone.`
        );
        return setTimeout(
          () => medirStreamConTimeout({ id: streamActualizado.id }),
          120 * 1000
        );
      }

      inicio = new Date(startTime);
      fin = new Date(endTime);

      console.log(`‚è±Ô∏è Usando horario obtenido desde YouTube (API)`);
    }

    console.log(`‚è∞ Hora actual: ${ahora.toTimeString().split(" ")[0]}`);
    console.log(`‚è±Ô∏è Inicio: ${inicio.toTimeString().split(" ")[0]}`);
    console.log(`‚è±Ô∏è Fin: ${fin.toTimeString().split(" ")[0]}`);

    let proximoIntervalo = 30 * 1000;

    if (ahora >= inicio &amp;&amp; ahora &lt;= fin &amp;&amp; activo) {
      console.log(
        `‚úÖ Dentro del horario. Ejecutando medici√≥n para ${streamActualizado.nombre_stream}`
      );
      await obtenerDatosYouTube(streamActualizado);
      proximoIntervalo = intervalo_medicion * 60 * 1000;
    } else {
      console.log(
        `‚è∞ Medici√≥n no realizada para ${streamActualizado.nombre_stream}: fuera del rango horario o stream detenido.`
      );
    }

    console.log(
      `üîÑ Pr√≥xima medici√≥n en ${proximoIntervalo / 1000} segundos para ${
        streamActualizado.nombre_stream
      }`
    );
    setTimeout(
      () => medirStreamConTimeout({ id: streamActualizado.id }),
      proximoIntervalo
    );
  } catch (error) {
    console.error("‚ùå Error en medici√≥n din√°mica:", error);
  }
}

/**
 * Inicia el proceso de mediciones luego de verificar la conexi√≥n a la base de datos.
 */
async function iniciarMediciones() {
  try {
    await sequelize.authenticate();
    console.log("‚úÖ Conectado a la base de datos para iniciar mediciones.");
    supervisor();
  } catch (error) {
    console.error("‚ùå Error al iniciar mediciones:", error);
  }
}

export default iniciarMediciones;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="controllers_home.controller%250A%250AEste%2520m%25C3%25B3dulo%2520define%2520el%2520controlador%2520de%2520la%2520p%25C3%25A1gina%2520principal%2520del%2520sistema.%250ASe%2520encarga%2520de%2520renderizar%2520la%2520vista%2520de%2520inicio%2520(_home_index_).module_.html">controllers/home.controller

Este m√≥dulo define el controlador de la p√°gina principal del sistema.
Se encarga de renderizar la vista de inicio ('home/index').</a></li><li><a href="module-app.html">app</a></li><li><a href="module-server.html">server</a></li><li><a href="module-utils.html">utils</a></li><li><a href="module-utils_pathHelper.html">utils/pathHelper</a></li></ul><h3>Global</h3><ul><li><a href="global.html#actualizarStream">actualizarStream</a></li><li><a href="global.html#apiKey">apiKey</a></li><li><a href="global.html#autocompletarIdCanal">autocompletarIdCanal</a></li><li><a href="global.html#canalEstaEnVivo">canalEstaEnVivo</a></li><li><a href="global.html#convertirAHoraArgentina">convertirAHoraArgentina</a></li><li><a href="global.html#dataTable">dataTable</a></li><li><a href="global.html#eliminarStream">eliminarStream</a></li><li><a href="global.html#extractHandle">extractHandle</a></li><li><a href="global.html#extraerVideoID">extraerVideoID</a></li><li><a href="global.html#formatearFecha">formatearFecha</a></li><li><a href="global.html#formatearHora">formatearHora</a></li><li><a href="global.html#formularioAgregar">formularioAgregar</a></li><li><a href="global.html#formularioEditar">formularioEditar</a></li><li><a href="global.html#generarGrafico">generarGrafico</a></li><li><a href="global.html#generarTabla">generarTabla</a></li><li><a href="global.html#guardarStream">guardarStream</a></li><li><a href="global.html#iniciarMediciones">iniciarMediciones</a></li><li><a href="global.html#medirStreamConTimeout">medirStreamConTimeout</a></li><li><a href="global.html#mostrarAlertaManual">mostrarAlertaManual</a></li><li><a href="global.html#mostrarFormulario">mostrarFormulario</a></li><li><a href="global.html#obtenerChannelIdDesdeURL">obtenerChannelIdDesdeURL</a></li><li><a href="global.html#obtenerDatosYouTube">obtenerDatosYouTube</a></li><li><a href="global.html#obtenerIdCanal">obtenerIdCanal</a></li><li><a href="global.html#obtenerIdDesdeHandle">obtenerIdDesdeHandle</a></li><li><a href="global.html#obtenerIdDesdeUsername">obtenerIdDesdeUsername</a></li><li><a href="global.html#obtenerNombreDesdeURL">obtenerNombreDesdeURL</a></li><li><a href="global.html#sequelize">sequelize</a></li><li><a href="global.html#supervisor">supervisor</a></li><li><a href="global.html#syncDatabase">syncDatabase</a></li><li><a href="global.html#toggleStream">toggleStream</a></li><li><a href="global.html#verStream">verStream</a></li><li><a href="global.html#verStreams">verStreams</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Jul 19 2025 13:59:57 GMT-0300 (Argentina Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
